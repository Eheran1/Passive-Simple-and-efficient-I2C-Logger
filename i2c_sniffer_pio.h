// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //


#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

#define SDA_PIN 8
#define SCL_PIN 9
#define EV0_PIN 10
#define EV1_PIN 11
#define IRQ_EVENT 7
#define EV_DATA 0
#define EV_START 1
#define EV_STOP 3

// --------- //
// i2c_start //
// --------- //

#define i2c_start_wrap_target 0
#define i2c_start_wrap 5

static const uint16_t i2c_start_program_instructions[] = {
            //     .wrap_target
    0x2008, //  0: wait   0 gpio, 8                  
    0x00c3, //  1: jmp    pin, 3                     
    0x0005, //  2: jmp    5                          
    0xe001, //  3: set    pins, 1                    
    0xc027, //  4: irq    wait 7                     
    0x2088, //  5: wait   1 gpio, 8                  
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2c_start_program = {
    .instructions = i2c_start_program_instructions,
    .length = 6,
    .origin = -1,
};

static inline pio_sm_config i2c_start_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2c_start_wrap_target, offset + i2c_start_wrap);
    return c;
}
#endif

// -------- //
// i2c_stop //
// -------- //

#define i2c_stop_wrap_target 0
#define i2c_stop_wrap 5

static const uint16_t i2c_stop_program_instructions[] = {
            //     .wrap_target
    0x2088, //  0: wait   1 gpio, 8                  
    0x00c3, //  1: jmp    pin, 3                     
    0x0005, //  2: jmp    5                          
    0xe003, //  3: set    pins, 3                    
    0xc027, //  4: irq    wait 7                     
    0x2008, //  5: wait   0 gpio, 8                  
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2c_stop_program = {
    .instructions = i2c_stop_program_instructions,
    .length = 6,
    .origin = -1,
};

static inline pio_sm_config i2c_stop_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2c_stop_wrap_target, offset + i2c_stop_wrap);
    return c;
}
#endif

// -------- //
// i2c_data //
// -------- //

#define i2c_data_wrap_target 0
#define i2c_data_wrap 3

static const uint16_t i2c_data_program_instructions[] = {
            //     .wrap_target
    0x2089, //  0: wait   1 gpio, 9                  
    0xe000, //  1: set    pins, 0                    
    0xc027, //  2: irq    wait 7                     
    0x2009, //  3: wait   0 gpio, 9                  
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2c_data_program = {
    .instructions = i2c_data_program_instructions,
    .length = 4,
    .origin = -1,
};

static inline pio_sm_config i2c_data_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2c_data_wrap_target, offset + i2c_data_wrap);
    return c;
}
#endif

// -------- //
// i2c_main //
// -------- //

#define i2c_main_wrap_target 0
#define i2c_main_wrap 6

static const uint16_t i2c_main_program_instructions[] = {
            //     .wrap_target
    0x20c7, //  0: wait   1 irq, 7                   
    0xc047, //  1: irq    clear 7                    
    0x00c5, //  2: jmp    pin, 5                     
    0x4001, //  3: in     pins, 1                    
    0x0000, //  4: jmp    0                          
    0xa0c0, //  5: mov    isr, pins                  
    0x4069, //  6: in     null, 9                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2c_main_program = {
    .instructions = i2c_main_program_instructions,
    .length = 7,
    .origin = -1,
};

static inline pio_sm_config i2c_main_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2c_main_wrap_target, offset + i2c_main_wrap);
    return c;
}

// Helper function (for use in C program) to initialize this PIO program
void i2c_start_program_init(PIO pio, uint sm, uint offset, float div) {
    // Sets up state machine and wrap target. This function is automatically
    // generated in i2c_sniffer.pio.h.
    pio_sm_config c = i2c_start_program_get_default_config(offset);
    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, EV0_PIN);
    pio_gpio_init(pio, EV1_PIN);
    // Connect EV0 EV1 to SET pins (control with 'set' instruction)
    sm_config_set_set_pins(&c, EV0_PIN, 2);
    // Connect SCL_PIN to JMP pin to test the clock level.
    sm_config_set_jmp_pin(&c, SCL_PIN);
    // Set the SCL direction to input (in PIO)
    // EV0 and EV1 output, and SCL input.
    pio_sm_set_pins_with_mask(pio, sm, (1<<EV1_PIN) | (1<<EV0_PIN), 
                                       (1<<EV1_PIN) | (1<<EV0_PIN));
    pio_sm_set_pindirs_with_mask(pio, sm, (1<<EV1_PIN) | (1<<EV0_PIN),
                                          (1<<EV1_PIN) | (1<<EV0_PIN) | (1<<SCL_PIN));
    // wait GPIO : System GPIO input selected by Index . 
    // This is an absolute GPIO index, and is not affected by the state
    // machine’s input IO mapping.
    gpio_init(SDA_PIN);
    gpio_set_dir(SDA_PIN, GPIO_IN);
    gpio_disable_pulls(SDA_PIN);
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

// Helper function (for use in C program) to initialize this PIO program
void i2c_stop_program_init(PIO pio, uint sm, uint offset, float div) {
    // Sets up state machine and wrap target. This function is automatically
    // generated in i2c_sniffer.pio.h.
    pio_sm_config c = i2c_stop_program_get_default_config(offset);
    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, EV0_PIN);
    // Connect EV0 EV1 to SET pins (control with 'set' instruction)
    sm_config_set_set_pins(&c, EV0_PIN, 2);
    // Set the pin EV0 and EV1 direction to output (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, EV0_PIN, 2, true);
    // Connect SCL_PIN to JMP pin to test the clock level.
    sm_config_set_jmp_pin(&c, SCL_PIN);
    // Set the SCL direction to input (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, SCL_PIN, 1, false);
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

// Helper function (for use in C program) to initialize this PIO program
void i2c_data_program_init(PIO pio, uint sm, uint offset, float div) {
    // Sets up state machine and wrap target. This function is automatically
    // generated in i2c_sniffer.pio.h.
    pio_sm_config c = i2c_data_program_get_default_config(offset);
    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, EV0_PIN);
    pio_gpio_init(pio, EV1_PIN);
    // Connect EV0 EV1 to SET pins (control with 'set' instruction)
    sm_config_set_set_pins(&c, EV0_PIN, 2);
    // EV0 and EV1 output, and SCL input.
    pio_sm_set_pins_with_mask(pio, sm, (1<<EV1_PIN) | (1<<EV0_PIN), 
                                       (1<<EV1_PIN) | (1<<EV0_PIN));
    pio_sm_set_pindirs_with_mask(pio, sm, (1<<EV1_PIN) | (1<<EV0_PIN),
                                          (1<<EV1_PIN) | (1<<EV0_PIN) | (1<<SCL_PIN));
    // wait GPIO : System GPIO input selected by Index . 
    // This is an absolute GPIO index, and is not affected by the state
    // machine’s input IO mapping.
    gpio_init(SCL_PIN);
    gpio_set_dir(SCL_PIN, GPIO_IN);
    gpio_disable_pulls(SCL_PIN);
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);
    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

// Helper function (for use in C program) to initialize this PIO program
void i2c_main_program_init(PIO pio, uint sm, uint offset, float div) {
    pio_sm_config c = i2c_main_program_get_default_config(offset);

    // Initialize all pins: SDA,SCL inputs; EV0,EV1 outputs
    pio_gpio_init(pio, SDA_PIN);
    pio_gpio_init(pio, SCL_PIN);
    pio_gpio_init(pio, EV0_PIN);
    pio_gpio_init(pio, EV1_PIN);

    // Set directions explicitly:
    pio_sm_set_consecutive_pindirs(pio, sm, SDA_PIN, 2, false); // SDA(8),SCL(9)=inputs
    pio_sm_set_consecutive_pindirs(pio, sm, EV0_PIN, 2, true);  // EV0(10),EV1(11)=outputs

    // Connect the pins correctly for reading into ISR
    sm_config_set_in_pins(&c, SDA_PIN); // base = 8 (SDA), reads 8,9,10,11 into ISR

    // Set the jmp pin correctly:
    sm_config_set_jmp_pin(&c, EV0_PIN); // jmp pin = EV0 (10)

    sm_config_set_in_shift(&c, false, true, 9); // left shift, autopush at 9 bits
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset, &c);
}

#endif
